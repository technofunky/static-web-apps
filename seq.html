<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sequence Diagram Generator</title>
  <style>
    :root {
      --primary-color: #4285f4;
      --secondary-color: #34a853;
      --danger-color: #ea4335;
      --warning-color: #fbbc04;
      --light-gray: #f5f5f5;
      --border-color: #ddd;
      --text-color: #333;
      --bg-color: #f9f9f9;
    }
    
    [data-theme="dark"] {
      --primary-color: #8ab4f8;
      --secondary-color: #81c995;
      --danger-color: #f28b82;
      --warning-color: #fdd663;
      --light-gray: #2d2d2d;
      --border-color: #444;
      --text-color: #e8eaed;
      --bg-color: #1a1a1a;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 20px;
      color: var(--text-color);
      line-height: 1.6;
      background-color: var(--bg-color);
      transition: background-color 0.3s, color 0.3s;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    [data-theme="dark"] .container {
      background: #202124;
    }
    
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    h1, h2, h3 {
      color: var(--primary-color);
      margin-top: 0;
    }
    
    h1 {
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 10px;
      flex: 1;
      min-width: 200px;
    }
    
    .theme-toggle {
      background: var(--light-gray);
      border: 1px solid var(--border-color);
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    
    th {
      background-color: var(--primary-color);
      color: white;
      text-align: left;
    }
    
    th, td {
      padding: 12px 15px;
      border: 1px solid var(--border-color);
    }
    
    tr:nth-child(even) {
      background-color: var(--light-gray);
    }
    
    tr:hover {
      background-color: rgba(66, 133, 244, 0.1);
    }
    
    .form-container {
      margin-bottom: 25px;
      padding: 15px;
      background-color: var(--light-gray);
      border-radius: 5px;
      border: 1px solid var(--border-color);
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
    }
    
    input, select, button, textarea {
      padding: 8px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 14px;
      background-color: white;
      color: var(--text-color);
    }
    
    [data-theme="dark"] input,
    [data-theme="dark"] select,
    [data-theme="dark"] textarea {
      background-color: #2d2d2d;
      color: var(--text-color);
    }
    
    input[type="text"], select {
      width: 200px;
    }
    
    textarea {
      width: 100%;
      min-height: 120px;
      resize: vertical;
      font-family: 'Courier New', monospace;
    }
    
    button {
      background-color: var(--primary-color);
      color: white;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.1s;
      margin-right: 10px;
    }
    
    button:hover {
      background-color: #3367d6;
      transform: translateY(-1px);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button.secondary {
      background-color: var(--secondary-color);
    }
    
    button.secondary:hover {
      background-color: #2d9249;
    }
    
    button.danger {
      background-color: var(--danger-color);
    }
    
    button.danger:hover {
      background-color: #d33426;
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    pre {
      background: var(--light-gray);
      padding: 15px;
      border: 1px solid var(--border-color);
      white-space: pre-wrap;
      border-radius: 4px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 13px;
    }
    
    canvas {
      border: 1px solid var(--border-color);
      margin-top: 20px;
      display: block;
      background: white;
      max-width: 100%;
      border-radius: 4px;
    }
    
    .canvas-controls {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    
    .actor-list {
      list-style: none;
      padding: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    
    .actor-item {
      background-color: var(--primary-color);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
      transition: transform 0.2s;
    }
    
    .actor-item:hover {
      transform: scale(1.05);
    }
    
    .actor-item button {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      margin: 0;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 16px;
      border-radius: 3px;
    }
    
    .actor-item button:hover {
      background: rgba(255, 255, 255, 0.3);
    }
    
    .btn-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    
    .btn-group button {
      margin-right: 0;
    }
    
    .alert {
      padding: 12px 15px;
      border-radius: 4px;
      margin: 10px 0;
      display: none;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .alert.success {
      background-color: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .alert.error {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .alert.warning {
      background-color: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    
    .message-type-select {
      width: 120px;
    }
    
    .templates {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    
    .template-card {
      padding: 10px 15px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }
    
    [data-theme="dark"] .template-card {
      background: #2d2d2d;
    }
    
    .template-card:hover {
      border-color: var(--primary-color);
      box-shadow: 0 2px 8px rgba(66, 133, 244, 0.2);
    }
    
    .template-card h4 {
      margin: 0 0 5px 0;
      color: var(--primary-color);
    }
    
    .template-card p {
      margin: 0;
      font-size: 12px;
      color: #666;
    }
    
    [data-theme="dark"] .template-card p {
      color: #aaa;
    }
    
    .keyboard-shortcuts {
      font-size: 12px;
      color: #666;
      margin-top: 10px;
      padding: 10px;
      background: var(--light-gray);
      border-radius: 4px;
    }
    
    .keyboard-shortcuts kbd {
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 2px 6px;
      font-family: monospace;
      font-size: 11px;
    }
    
    [data-theme="dark"] .keyboard-shortcuts kbd {
      background: #2d2d2d;
    }
    
    @media (max-width: 768px) {
      input[type="text"], select {
        width: 100%;
        margin-bottom: 10px;
      }
      
      .form-container {
        padding: 10px;
      }
      
      th, td {
        padding: 8px 10px;
        font-size: 14px;
      }
      
      .actor-list {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .btn-group {
        flex-direction: column;
      }
      
      .btn-group button {
        width: 100%;
      }
    }
  </style>
</head>
<body>

<div class="container">
  <div class="header">
    <h1>Sequence Diagram Generator</h1>
    <button class="theme-toggle" onclick="toggleTheme()">üåì Toggle Theme</button>
  </div>
  
  <div id="alert" class="alert"></div>

  <div class="form-container">
    <h2>Quick Start Templates</h2>
    <div class="templates">
      <div class="template-card" onclick="loadTemplate('login')">
        <h4>Login Flow</h4>
        <p>User authentication example</p>
      </div>
      <div class="template-card" onclick="loadTemplate('api')">
        <h4>API Request</h4>
        <p>REST API interaction</p>
      </div>
      <div class="template-card" onclick="loadTemplate('payment')">
        <h4>Payment Process</h4>
        <p>E-commerce checkout</p>
      </div>
    </div>
  </div>

  <div class="form-container">
    <h2>Actors Management</h2>
    <div class="form-group">
      <label for="actor">Actor Name:</label>
      <input type="text" id="actor" placeholder="Enter actor name" onkeypress="handleActorKeyPress(event)">
    </div>
    <div class="btn-group">
      <button onclick="addActor()">‚ûï Add Actor</button>
      <button class="secondary" onclick="showRenameDialog()">‚úèÔ∏è Rename Actor</button>
    </div>
    
    <h3>Current Actors:</h3>
    <ul id="actorList" class="actor-list"></ul>
    
    <div class="keyboard-shortcuts">
      <strong>üí° Tip:</strong> Press <kbd>Enter</kbd> to quickly add actors
    </div>
  </div>

  <div class="form-container">
    <h2>Sequence Steps</h2>
    <button onclick="addRow()" class="secondary">‚ûï Add Step</button>
    
    <div style="overflow-x: auto;">
      <table id="sequenceTable">
        <thead>
          <tr>
            <th>From</th>
            <th>To</th>
            <th>Message</th>
            <th>Type</th>
            <th>Actions</th>
            <th>Move</th>
          </tr>
        </thead>
        <tbody>
          <!-- Rows will be added dynamically -->
        </tbody>
      </table>
    </div>
  </div>

  <div class="form-container">
    <h2>Generate Diagram</h2>
    <div class="btn-group">
      <button onclick="generatePlantUML()">üîÑ Generate PlantUML</button>
      <button onclick="copyToClipboard()">üìã Copy to Clipboard</button>
      <button onclick="exportAsPNG()">üíæ Export as PNG</button>
      <button onclick="clearAll()" class="danger">üóëÔ∏è Clear All</button>
    </div>
  </div>

  <div class="form-container">
    <h2>PlantUML Script</h2>
    <pre id="plantUMLOutput">Click "Generate PlantUML" to see the output here.</pre>
  </div>

  <div class="form-container">
    <h2>Import/Export</h2>
    <div class="form-group">
      <label for="plantUMLInput">Paste PlantUML Script:</label>
      <textarea id="plantUMLInput" placeholder="@startuml&#10;participant User&#10;participant System&#10;User -> System : Login Request&#10;System --> User : Login Response&#10;@enduml"></textarea>
    </div>
    <div class="btn-group">
      <button onclick="parsePlantUML()">üì• Import from Script</button>
      <button onclick="exportAsJSON()">üíæ Export as JSON</button>
      <button onclick="importFromJSON()">üìÇ Import from JSON</button>
    </div>
  </div>

  <div class="form-container">
    <h2>Diagram Preview</h2>
    <div class="canvas-controls">
      <button onclick="zoomCanvas(1.2)">üîç Zoom In</button>
      <button onclick="zoomCanvas(0.8)">üîç Zoom Out</button>
      <button onclick="resetZoom()">‚Üª Reset Zoom</button>
    </div>
    <canvas id="sequenceCanvas" width="800" height="400"></canvas>
  </div>
</div>

<script>
  // State management (in-memory only)
  const state = {
    actors: [],
    tableData: [],
    canvasZoom: 1,
    theme: 'light'
  };

  // Templates
  const templates = {
    login: {
      actors: ['User', 'Frontend', 'Backend', 'Database'],
      messages: [
        { actor1: 'User', actor2: 'Frontend', message: 'Enter credentials', type: 'sync' },
        { actor1: 'Frontend', actor2: 'Backend', message: 'POST /login', type: 'sync' },
        { actor1: 'Backend', actor2: 'Database', message: 'Validate user', type: 'sync' },
        { actor1: 'Database', actor2: 'Backend', message: 'User data', type: 'return' },
        { actor1: 'Backend', actor2: 'Frontend', message: 'Auth token', type: 'return' },
        { actor1: 'Frontend', actor2: 'User', message: 'Login successful', type: 'return' }
      ]
    },
    api: {
      actors: ['Client', 'API Gateway', 'Service', 'Database'],
      messages: [
        { actor1: 'Client', actor2: 'API Gateway', message: 'GET /api/data', type: 'sync' },
        { actor1: 'API Gateway', actor2: 'Service', message: 'Process request', type: 'sync' },
        { actor1: 'Service', actor2: 'Database', message: 'Query data', type: 'sync' },
        { actor1: 'Database', actor2: 'Service', message: 'Result set', type: 'return' },
        { actor1: 'Service', actor2: 'API Gateway', message: 'Formatted response', type: 'return' },
        { actor1: 'API Gateway', actor2: 'Client', message: '200 OK + Data', type: 'return' }
      ]
    },
    payment: {
      actors: ['Customer', 'Store', 'Payment Gateway', 'Bank'],
      messages: [
        { actor1: 'Customer', actor2: 'Store', message: 'Checkout', type: 'sync' },
        { actor1: 'Store', actor2: 'Payment Gateway', message: 'Process payment', type: 'sync' },
        { actor1: 'Payment Gateway', actor2: 'Bank', message: 'Authorize transaction', type: 'sync' },
        { actor1: 'Bank', actor2: 'Payment Gateway', message: 'Approved', type: 'return' },
        { actor1: 'Payment Gateway', actor2: 'Store', message: 'Payment confirmed', type: 'return' },
        { actor1: 'Store', actor2: 'Customer', message: 'Order confirmed', type: 'return' }
      ]
    }
  };

  // DOM elements
  const elements = {
    actorInput: document.getElementById('actor'),
    actorList: document.getElementById('actorList'),
    sequenceTable: document.getElementById('sequenceTable').querySelector('tbody'),
    plantUMLInput: document.getElementById('plantUMLInput'),
    plantUMLOutput: document.getElementById('plantUMLOutput'),
    sequenceCanvas: document.getElementById('sequenceCanvas'),
    alert: document.getElementById('alert')
  };

  // Initialize the app
  window.onload = () => {
    loadTheme();
  };

  // Theme management
  function toggleTheme() {
    state.theme = state.theme === 'light' ? 'dark' : 'light';
    document.documentElement.setAttribute('data-theme', state.theme);
    try {
      localStorage.setItem('theme', state.theme);
    } catch(e) {
      console.warn('Could not save theme preference');
    }
    regenerateDiagram();
  }

  function loadTheme() {
    try {
      const savedTheme = localStorage.getItem('theme') || 'light';
      state.theme = savedTheme;
      document.documentElement.setAttribute('data-theme', savedTheme);
    } catch(e) {
      state.theme = 'light';
    }
  }

  // Helper functions
  function showAlert(message, type = 'success') {
    const alert = elements.alert;
    alert.textContent = message;
    alert.className = `alert ${type}`;
    alert.style.display = 'block';
    
    setTimeout(() => {
      alert.style.display = 'none';
    }, 4000);
  }

  function validateDiagram() {
    if (state.actors.length === 0) {
      showAlert('Please add at least one actor', 'warning');
      return false;
    }
    
    const rows = elements.sequenceTable.querySelectorAll('tr');
    if (rows.length === 0) {
      showAlert('Please add at least one step', 'warning');
      return false;
    }
    
    let hasValidStep = false;
    rows.forEach(row => {
      const actor1 = row.cells[0].querySelector('select').value;
      const actor2 = row.cells[1].querySelector('select').value;
      const message = row.cells[2].querySelector('input').value.trim();
      if (actor1 && actor2 && message) {
        hasValidStep = true;
      }
    });
    
    if (!hasValidStep) {
      showAlert('Please add at least one complete step (with actors and message)', 'warning');
      return false;
    }
    
    return true;
  }

  // Actor management
  function addActor() {
    const actorName = elements.actorInput.value.trim();

    if (!actorName) {
      showAlert('Please enter an actor name', 'error');
      return;
    }

    if (state.actors.includes(actorName)) {
      showAlert(`Actor "${actorName}" already exists`, 'error');
      return;
    }

    state.actors.push(actorName);
    elements.actorInput.value = '';
    renderActorList();
    showAlert(`Actor "${actorName}" added successfully`);
  }

  function handleActorKeyPress(event) {
    if (event.key === 'Enter') {
      event.preventDefault();
      addActor();
    }
  }

  function deleteActor(index) {
    const removedActor = state.actors[index];
    
    // Check if actor is used in any steps
    const rows = elements.sequenceTable.querySelectorAll('tr');
    let usageCount = 0;
    rows.forEach(row => {
      const actor1 = row.cells[0].querySelector('select').value;
      const actor2 = row.cells[1].querySelector('select').value;
      if (actor1 === removedActor || actor2 === removedActor) {
        usageCount++;
      }
    });
    
    if (usageCount > 0) {
      if (!confirm(`Actor "${removedActor}" is used in ${usageCount} step(s). Delete anyway?`)) {
        return;
      }
      
      // Remove rows that contain this actor
      rows.forEach(row => {
        const actor1 = row.cells[0].querySelector('select').value;
        const actor2 = row.cells[1].querySelector('select').value;
        if (actor1 === removedActor || actor2 === removedActor) {
          row.remove();
        }
      });
    }
    
    state.actors.splice(index, 1);
    renderActorList();
    showAlert(`Actor "${removedActor}" deleted`);
  }

  function showRenameDialog() {
    if (state.actors.length === 0) {
      showAlert('No actors to rename', 'error');
      return;
    }
    
    const oldName = prompt('Enter the actor name to rename:', state.actors[0]);
    if (!oldName) return;
    
    const index = state.actors.indexOf(oldName);
    if (index === -1) {
      showAlert(`Actor "${oldName}" not found`, 'error');
      return;
    }
    
    const newName = prompt(`Enter new name for "${oldName}":`, oldName);
    if (!newName || newName === oldName) return;
    
    if (state.actors.includes(newName)) {
      showAlert(`Actor "${newName}" already exists`, 'error');
      return;
    }
    
    // Update actor name
    state.actors[index] = newName;
    
    // Update all references in table
    const rows = elements.sequenceTable.querySelectorAll('tr');
    rows.forEach(row => {
      const select1 = row.cells[0].querySelector('select');
      const select2 = row.cells[1].querySelector('select');
      if (select1.value === oldName) select1.value = newName;
      if (select2.value === oldName) select2.value = newName;
    });
    
    renderActorList();
    showAlert(`Actor renamed from "${oldName}" to "${newName}"`);
  }

  function renderActorList() {
    elements.actorList.innerHTML = '';
    
    if (state.actors.length === 0) {
      const li = document.createElement('li');
      li.textContent = 'No actors added yet';
      li.style.color = '#666';
      elements.actorList.appendChild(li);
      return;
    }
    
    state.actors.forEach((actor, index) => {
      const tag = document.createElement('div');
      tag.className = 'actor-item';
      
      const name = document.createElement('span');
      name.textContent = actor;
      tag.appendChild(name);
      
      const deleteBtn = document.createElement('button');
      deleteBtn.innerHTML = '√ó';
      deleteBtn.title = 'Delete this actor';
      deleteBtn.onclick = (e) => {
        e.stopPropagation();
        deleteActor(index);
      };
      
      tag.appendChild(deleteBtn);
      elements.actorList.appendChild(tag);
    });
    
    refreshDropdowns();
  }

  function refreshDropdowns() {
    const rows = elements.sequenceTable.querySelectorAll('tr');
    rows.forEach(row => {
      ['actor1', 'actor2'].forEach((id, i) => {
        const cell = row.cells[i];
        const currentValue = cell.querySelector('select')?.value || '';
        
        const newSelect = createActorDropdown(currentValue);
        cell.innerHTML = '';
        cell.appendChild(newSelect);
      });
    });
  }

  function createActorDropdown(selectedValue = '') {
    const select = document.createElement('select');
    
    if (!selectedValue) {
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      emptyOption.textContent = '-- Select --';
      emptyOption.selected = true;
      select.appendChild(emptyOption);
    }
    
    state.actors.forEach(actor => {
      const option = document.createElement('option');
      option.value = actor;
      option.textContent = actor;
      if (actor === selectedValue) {
        option.selected = true;
      }
      select.appendChild(option);
    });
    
    return select;
  }

  // Table row management
  function addRow(actor1 = '', actor2 = '', message = '', type = 'sync') {
    const row = document.createElement('tr');
    
    const actor1Cell = document.createElement('td');
    const actor2Cell = document.createElement('td');
    const messageCell = document.createElement('td');
    const typeCell = document.createElement('td');
    const actionCell = document.createElement('td');
    const reorderCell = document.createElement('td');
    
    const actor1Select = createActorDropdown(actor1);
    const actor2Select = createActorDropdown(actor2);
    
    const messageInput = document.createElement('input');
    messageInput.type = 'text';
    messageInput.value = message;
    messageInput.placeholder = 'Enter message';
    messageInput.style.width = '100%';
    
    const typeSelect = document.createElement('select');
    typeSelect.className = 'message-type-select';
    ['sync', 'return', 'async'].forEach(t => {
      const option = document.createElement('option');
      option.value = t;
      option.textContent = t === 'sync' ? 'Request' : t === 'return' ? 'Response' : 'Async';
      if (t === type) option.selected = true;
      typeSelect.appendChild(option);
    });
    
    const deleteButton = document.createElement('button');
    deleteButton.className = 'danger';
    deleteButton.textContent = 'üóëÔ∏è';
    deleteButton.onclick = () => {
      row.remove();
      showAlert('Step deleted');
      regenerateDiagram();
    };
    
    const upButton = document.createElement('button');
    upButton.textContent = '‚Üë';
    upButton.title = 'Move up';
    upButton.onclick = () => moveRow(row, 'up');
    
    const downButton = document.createElement('button');
    downButton.textContent = '‚Üì';
    downButton.title = 'Move down';
    downButton.onclick = () => moveRow(row, 'down');
    
    actor1Cell.appendChild(actor1Select);
    actor2Cell.appendChild(actor2Select);
    messageCell.appendChild(messageInput);
    typeCell.appendChild(typeSelect);
    actionCell.appendChild(deleteButton);
    reorderCell.appendChild(upButton);
    reorderCell.appendChild(downButton);
    
    row.appendChild(actor1Cell);
    row.appendChild(actor2Cell);
    row.appendChild(messageCell);
    row.appendChild(typeCell);
    row.appendChild(actionCell);
    row.appendChild(reorderCell);
    
    elements.sequenceTable.appendChild(row);
  }

  function moveRow(row, direction) {
    const rows = Array.from(elements.sequenceTable.querySelectorAll('tr'));
    const index = rows.indexOf(row);
    
    if (direction === 'up' && index > 0) {
      elements.sequenceTable.insertBefore(row, rows[index - 1]);
      regenerateDiagram();
    } else if (direction === 'down' && index < rows.length - 1) {
      elements.sequenceTable.insertBefore(rows[index + 1], row);
      regenerateDiagram();
    }
  }

  function regenerateDiagram() {
    if (state.actors.length > 0) {
      generatePlantUML();
    }
  }

  // PlantUML generation
  function generatePlantUML() {
    if (!validateDiagram()) return;
    
    const rows = elements.sequenceTable.querySelectorAll('tr');
    let plantUMLScript = '@startuml\n';
    plantUMLScript += `title Sequence Diagram\n\n`;
    
    state.actors.forEach(actor => {
      plantUMLScript += `participant "${actor}" as ${actor.replace(/\s+/g, '_')}\n`;
    });
    
    plantUMLScript += '\n';
    
    rows.forEach(row => {
      const actor1 = row.cells[0].querySelector('select').value;
      const actor2 = row.cells[1].querySelector('select').value;
      const message = row.cells[2].querySelector('input').value.trim();
      const type = row.cells[3].querySelector('select').value;
      
      if (actor1 && actor2 && message) {
        const a1 = actor1.replace(/\s+/g, '_');
        const a2 = actor2.replace(/\s+/g, '_');
        
        if (type === 'return') {
          plantUMLScript += `${a2} --> ${a1} : ${message}\n`;
        } else if (type === 'async') {
          plantUMLScript += `${a1} ->> ${a2} : ${message}\n`;
        } else {
          plantUMLScript += `${a1} -> ${a2} : ${message}\n`;
        }
      }
    });
    
    plantUMLScript += '@enduml';
    
    elements.plantUMLOutput.textContent = plantUMLScript;
    renderCanvas(plantUMLScript);
  }

  function copyToClipboard() {
    const plantUMLScript = elements.plantUMLOutput.textContent;
    if (!plantUMLScript || plantUMLScript === 'Click "Generate PlantUML" to see the output here.') {
      showAlert('Nothing to copy. Generate a script first.', 'error');
      return;
    }
    
    navigator.clipboard.writeText(plantUMLScript).then(() => {
      showAlert('PlantUML script copied to clipboard!');
    }).catch(err => {
      showAlert('Failed to copy text: ' + err, 'error');
    });
  }

  function parsePlantUML() {
    const input = elements.plantUMLInput.value.trim();
    if (!input) {
      showAlert('Please enter a PlantUML script', 'error');
      return;
    }
    
    elements.sequenceTable.innerHTML = '';
    state.actors = [];
    
    const lines = input.split('\n');
    const newRows = [];
    
    lines.forEach(line => {
      line = line.trim();
      
      if (!line || line.startsWith("'") || line.startsWith('@') || line.startsWith('title')) {
        return;
      }
      
      if (line.startsWith('participant') || line.startsWith('actor')) {
        const match = line.match(/(?:participant|actor)\s+"([^"]+)"|(?:participant|actor)\s+(\S+)/);
        if (match) {
          const actorName = (match[1] || match[2]).replace(/_/g, ' ');
          if (!state.actors.includes(actorName)) {
            state.actors.push(actorName);
          }
        }
      }
      else if (line.includes('->') || line.includes('-->') || line.includes('->>')) {
        let type = 'sync';
        let separator = '->';
        
        if (line.includes('-->')) {
          type = 'return';
          separator = '-->';
        } else if (line.includes('->>')) {
          type = 'async';
          separator = '->>';
        }
        
        const parts = line.split(separator);
        if (parts.length === 2) {
          const actor1 = parts[0].trim().replace(/_/g, ' ');
          const rightPart = parts[1].split(':');
          const actor2 = rightPart[0].trim().replace(/_/g, ' ');
          const message = rightPart[1] ? rightPart[1].trim() : '';
          
          if (actor1 && actor2) {
            if (!state.actors.includes(actor1)) state.actors.push(actor1);
            if (!state.actors.includes(actor2)) state.actors.push(actor2);
            newRows.push({ actor1, actor2, message, type });
          }
        }
      }
    });
    
    renderActorList();
    newRows.forEach(row => addRow(row.actor1, row.actor2, row.message, row.type));
    showAlert('Diagram imported from PlantUML script!');
    generatePlantUML();
  }

  // Template loading
  function loadTemplate(templateName) {
    const template = templates[templateName];
    if (!template) return;
    
    if (state.actors.length > 0 || elements.sequenceTable.querySelectorAll('tr').length > 0) {
      if (!confirm('Loading a template will replace your current diagram. Continue?')) {
        return;
      }
    }
    
    elements.sequenceTable.innerHTML = '';
    state.actors = [...template.actors];
    
    renderActorList();
    template.messages.forEach(msg => {
      addRow(msg.actor1, msg.actor2, msg.message, msg.type || 'sync');
    });
    
    showAlert(`Template "${templateName}" loaded successfully!`);
    generatePlantUML();
  }

  // Import/Export functionality
  function exportAsJSON() {
    const rows = elements.sequenceTable.querySelectorAll('tr');
    const messages = [];
    
    rows.forEach(row => {
      const actor1 = row.cells[0].querySelector('select').value;
      const actor2 = row.cells[1].querySelector('select').value;
      const message = row.cells[2].querySelector('input').value.trim();
      const type = row.cells[3].querySelector('select').value;
      if (actor1 && actor2 && message) {
        messages.push({ actor1, actor2, message, type });
      }
    });
    
    const data = {
      actors: state.actors,
      messages: messages,
      plantUML: elements.plantUMLOutput.textContent
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sequence-diagram.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showAlert('Diagram exported as JSON file');
  }

  function importFromJSON() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = e => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = event => {
        try {
          const data = JSON.parse(event.target.result);
          
          elements.sequenceTable.innerHTML = '';
          state.actors = data.actors || [];
          
          renderActorList();
          (data.messages || []).forEach(row => {
            addRow(row.actor1, row.actor2, row.message, row.type || 'sync');
          });
          
          if (data.plantUML) {
            elements.plantUMLOutput.textContent = data.plantUML;
            renderCanvas(data.plantUML);
          }
          
          showAlert('Diagram imported from JSON file');
        } catch (err) {
          showAlert('Error parsing JSON file: ' + err.message, 'error');
        }
      };
      reader.readAsText(file);
    };
    
    input.click();
  }

  function clearAll() {
    if (!confirm('Are you sure you want to clear all data? This cannot be undone.')) {
      return;
    }
    
    state.actors = [];
    
    elements.sequenceTable.innerHTML = '';
    elements.plantUMLInput.value = '';
    elements.plantUMLOutput.textContent = 'Click "Generate PlantUML" to see the output here.';
    
    const ctx = elements.sequenceCanvas.getContext('2d');
    ctx.clearRect(0, 0, elements.sequenceCanvas.width, elements.sequenceCanvas.height);
    
    renderActorList();
    showAlert('All data cleared');
  }

  // Canvas rendering
  function renderCanvas(plantUMLScript) {
    const canvas = elements.sequenceCanvas;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const lines = plantUMLScript.split('\n');
    const actorPositions = {};
    const actorY = 50;
    const lifelineYStart = actorY + 30;
    let lifelineYEnd = 400;
    let messageY = lifelineYStart + 20;
    
    // Count messages to calculate canvas height
    let messageCount = 0;
    lines.forEach(line => {
      if (line.includes('->') || line.includes('-->') || line.includes('->>')) {
        messageCount++;
      }
    });
    
    canvas.height = Math.max(400, 150 + messageCount * 50);
    lifelineYEnd = canvas.height - 50;
    
    // Apply zoom
    ctx.save();
    ctx.scale(state.canvasZoom, state.canvasZoom);
    
    // Set background based on theme
    const isDark = state.theme === 'dark';
    ctx.fillStyle = isDark ? '#202124' : 'white';
    ctx.fillRect(0, 0, canvas.width / state.canvasZoom, canvas.height / state.canvasZoom);
    
    // Draw actors and lifelines
    let actorIndex = 0;
    const actorSpacing = Math.min(150, (canvas.width - 200) / Math.max(1, state.actors.length - 1));
    
    lines.forEach(line => {
      line = line.trim();
      
      if (line.startsWith('participant') || line.startsWith('actor')) {
        const match = line.match(/(?:participant|actor)\s+"([^"]+)"|(?:participant|actor)\s+(\S+)/);
        if (match) {
          const actor = (match[1] || match[2]).replace(/_/g, ' ');
          const x = 100 + actorIndex * actorSpacing;
          actorPositions[actor] = x;
          
          // Draw actor box
          ctx.fillStyle = isDark ? '#8ab4f8' : '#4285f4';
          ctx.fillRect(x - 40, actorY - 15, 80, 30);
          
          // Draw actor label
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillStyle = 'white';
          ctx.fillText(actor, x, actorY + 5);
          
          // Draw lifeline
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(x, lifelineYStart);
          ctx.lineTo(x, lifelineYEnd);
          ctx.strokeStyle = isDark ? '#666' : '#888';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.closePath();
          ctx.setLineDash([]);
          
          actorIndex++;
        }
      }
    });
    
    // Draw messages
    ctx.strokeStyle = isDark ? '#e8eaed' : '#333';
    ctx.fillStyle = isDark ? '#e8eaed' : '#333';
    ctx.lineWidth = 2;
    
    lines.forEach(line => {
      if (line.includes('->') || line.includes('-->') || line.includes('->>')) {
        const isReturn = line.includes('-->');
        const isAsync = line.includes('->>');
        const separator = isReturn ? '-->' : isAsync ? '->>' : '->';
        
        const parts = line.split(separator);
        if (parts.length === 2) {
          const from = parts[0].trim().replace(/_/g, ' ');
          const rightPart = parts[1].split(':');
          const to = rightPart[0].trim().replace(/_/g, ' ');
          const message = rightPart[1] ? rightPart[1].trim() : '';
          
          const x1 = actorPositions[from];
          const x2 = actorPositions[to];
          
          if (x1 !== undefined && x2 !== undefined) {
            // Draw line
            if (isReturn) {
              ctx.setLineDash([5, 5]);
            }
            
            ctx.beginPath();
            ctx.moveTo(x1, messageY);
            ctx.lineTo(x2, messageY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw arrowhead
            const arrowSize = 8;
            const direction = x2 > x1 ? 1 : -1;
            
            ctx.beginPath();
            ctx.moveTo(x2, messageY);
            ctx.lineTo(x2 - direction * arrowSize, messageY - arrowSize / 2);
            ctx.lineTo(x2 - direction * arrowSize, messageY + arrowSize / 2);
            ctx.closePath();
            ctx.fill();
            
            // Draw message text
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(message, (x1 + x2) / 2, messageY - 10);
            
            messageY += 50;
          }
        }
      }
    });
    
    ctx.restore();
  }

  // Canvas zoom controls
  function zoomCanvas(factor) {
    state.canvasZoom *= factor;
    state.canvasZoom = Math.max(0.5, Math.min(3, state.canvasZoom));
    regenerateDiagram();
  }

  function resetZoom() {
    state.canvasZoom = 1;
    regenerateDiagram();
  }

  // Export canvas as PNG
  function exportAsPNG() {
    if (!validateDiagram()) return;
    
    const canvas = elements.sequenceCanvas;
    canvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sequence-diagram.png';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showAlert('Diagram exported as PNG');
    });
  }

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + S to export JSON
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
      e.preventDefault();
      exportAsJSON();
    }
  });
</script>
</body>
</html>
